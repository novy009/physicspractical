<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reflection of Light — Educational Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#22c1c3;--muted:#9aa6b2}
    *{box-sizing:border-box}
    body{margin:0;font-family:'Poppins',sans-serif;background:linear-gradient(180deg,#071022 0%,#0b1220 100%);color:#e6eef6;display:flex;align-items:flex-start;justify-content:center;min-height:100vh;padding-top:20px;padding-bottom:20px}
    .app{width:980px;max-width:96%;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.6);overflow:hidden;display:grid;grid-template-columns:1fr 360px}
    .left{padding:18px 18px 24px}
    h1{margin:0 0 8px;font-size:20px}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    canvas{background:linear-gradient(180deg,#0b2433,#06202a);border-radius:8px;margin-top:16px;width:100%;height:560px;display:block}
    .right{background:linear-gradient(180deg,#071b26,#071226);padding:18px;border-left:1px solid rgba(255,255,255,0.03)}
    .panel{margin-bottom:14px}
    label{display:block;font-size:13px;margin-bottom:6px;color:var(--muted)}
    .controls{display:flex;gap:8px;align-items:center}
    input[type=range]{-webkit-appearance:none;height:8px;background:rgba(255,255,255,0.03);border-radius:8px;width:100%}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);box-shadow:0 2px 6px rgba(34,193,195,0.25)}
    .btn{background:var(--accent);color:#02111b;padding:8px 12px;border-radius:8px;border:none;font-weight:600;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    .info{font-size:13px;line-height:1.4;color:#dfeaf0}
    .level{display:flex;align-items:center;gap:8px}
    .target{width:14px;height:14px;background:#ffb86b;border-radius:50%;box-shadow:0 0 6px rgba(255,184,107,0.35)}
    footer{font-size:12px;color:var(--muted);margin-top:6px}
    .score{font-size:18px;font-weight:600}
    .small{font-size:12px;color:var(--muted)}
    .controls-row{display:flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Reflection of light educational game">
    <div class="left">
      <h1>Reflection of Light — Game</h1>
      <p class="lead">Rotate the mirror to make the reflected ray hit the glowing target. Learn the law of reflection while playing!</p>

      <canvas id="stage" width="900" height="560" aria-label="Game stage showing mirror, rays, and target"></canvas>

      <div style="display:flex;gap:10px;margin-top:12px;align-items:center;justify-content:space-between">
        <div class="small muted">Level: <span id="levelLabel">1</span></div>
        <div style="display:flex;gap:10px;align-items:center">
          <div class="score">Score: <span id="score">0</span></div>
          <button id="resetBtn" class="btn">Reset Level</button>
        </div>
      </div>

      <footer>
        Tip: Angle of incidence = Angle of reflection. Use the slider or drag the mirror to change its angle.
      </footer>
    </div>
    <div class="right">
      <div class="panel">
        <label>Mirror angle (degrees)</label>
        <div class="controls">
          <input id="angleRange" type="range" min="-80" max="80" value="0">
          <div style="width:46px;text-align:right" id="angleVal">0°</div>
        </div>
      </div>

      <div class="panel">
        <label>Controls</label>
        <div class="controls-row">
          <button id="fireBtn" class="btn">Fire Ray</button>
          <button id="autoBtn" class="btn" style="background:#1f6a8a">Auto Aim</button>
        </div>
      </div>

      <div class="panel">
        <label>Game rules</label>
        <div class="info">
          • You control the mirror orientation.<br>• Click <strong>Fire Ray</strong> to send a light ray from the source.<br>• Make the reflected ray hit the yellow target to score.<br>• Levels increase difficulty: target moves or distance increases.
        </div>
      </div>

      <div class="panel">
        <label>Progress</label>
        <div class="info" id="progressText">Hit the target to advance.</div>
      </div>

      <div class="panel">
        <label>Quick Quiz</label>
        <div class="info small" id="quizArea">What is the law of reflection? <br><button id="showAnswer" class="btn" style="margin-top:8px">Show Answer</button></div>
      </div>

    </div>
  </div>

  <script>
   
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    const W = canvas.width; const H = canvas.height;

  
    const angleRange = document.getElementById('angleRange');
    const angleVal = document.getElementById('angleVal');
    const fireBtn = document.getElementById('fireBtn');
    const autoBtn = document.getElementById('autoBtn');
    const resetBtn = document.getElementById('resetBtn');
    const levelLabel = document.getElementById('levelLabel');
    const scoreLabel = document.getElementById('score');
    const progressText = document.getElementById('progressText');
    const showAnswer = document.getElementById('showAnswer');

    
    const source = {x: 120, y: H/2}; 
    let mirror = {x: 500, y: H/2, angle: 0, length: 300};
    let target = {x: 820, y: H/2 + 80, r: 12};
    let rayInFlight = null;
    let score = 0;
    let level = 1;

    angleRange.addEventListener('input', (e)=>{
      mirror.angle = parseFloat(e.target.value);
      angleVal.textContent = mirror.angle.toFixed(0)+"°";
      draw();
    });

    
    fireBtn.addEventListener('click', ()=>{
      fireRay();
    });

    resetBtn.addEventListener('click', ()=>{ resetLevel(); });

    autoBtn.addEventListener('click', ()=>{ autoAim(); });

    showAnswer.addEventListener('click', ()=>{
      alert('Law of reflection: the angle of incidence equals the angle of reflection, measured from the normal.');
    });


    let dragging = false; let dragStart = null;
    canvas.addEventListener('pointerdown', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      const dx = mx-mirror.x, dy = my-mirror.y;
      if (Math.hypot(dx,dy) < 120){ dragging=true; dragStart={mx,my,angle:mirror.angle}; }
    });
    canvas.addEventListener('pointermove', (e)=>{
      if (!dragging) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      const sx = dragStart.mx - mirror.x, sy = dragStart.my - mirror.y;
      const ex = mx - mirror.x, ey = my - mirror.y;
      const a1 = Math.atan2(sy,sx), a2 = Math.atan2(ey,ex);
      let da = (a2 - a1) * 180/Math.PI;
      mirror.angle = ((dragStart.angle + da) + 540) % 360 - 180;
      if (mirror.angle > 80) mirror.angle = 80; if (mirror.angle < -80) mirror.angle = -80;
      angleRange.value = mirror.angle; angleVal.textContent = mirror.angle.toFixed(0)+"°";
      draw();
    });
    window.addEventListener('pointerup', ()=>{ dragging=false; dragStart=null; });

    function resetLevel(){
      rayInFlight = null;
      const pad = 80 + Math.min(level*8, 180);
      target.x = 720 + Math.random()*140;
      target.y = 120 + Math.random()*(H-240);
      progressText.textContent = 'Try to hit the target.';
      draw();
    }

    function nextLevel(){
      level++;
      levelLabel.textContent = level;
      score += 10;
      scoreLabel.textContent = score;
      progressText.textContent = 'Nice! Advanced to level '+level+'.';
      setTimeout(resetLevel,800);
    }

    function fireRay(){
      const dx = mirror.x - source.x, dy = mirror.y - source.y;
      const len = Math.hypot(dx,dy);
      const incDir = {x: dx/len, y: dy/len};

      const a = mirror.angle * Math.PI/180;
      const nx = Math.cos(a+Math.PI/2), ny = Math.sin(a+Math.PI/2); 
      const mx1 = mirror.x + Math.cos(a)*mirror.length/2, my1 = mirror.y + Math.sin(a)*mirror.length/2;
      const mx2 = mirror.x - Math.cos(a)*mirror.length/2, my2 = mirror.y - Math.sin(a)*mirror.length/2;

      const p0 = source, p1 = {x: source.x + incDir.x*2000, y: source.y + incDir.y*2000};
      const p2 = {x: mx1, y: my1}, p3 = {x: mx2, y: my2};

      const inter = lineIntersect(p0,p1,p2,p3);
      if (!inter){ progressText.textContent = 'Ray missed the mirror. Adjust mirror position/angle.'; draw(); return; }

      const onSegment = pointOnSegment(inter,p2,p3);
      if (!onSegment){ progressText.textContent = 'Ray hit outside the mirror. Rotate/drag mirror.'; draw(); return; }

      const normal = {x: nx, y: ny};
      const dot = incDir.x*normal.x + incDir.y*normal.y;
      const refl = {x: incDir.x - 2*dot*normal.x, y: incDir.y - 2*dot*normal.y};

      rayInFlight = {start: inter, dir: refl};
      animateRay();
    }

    function animateRay(){
      let t = 0; const speed = 8;
      const maxT = 2000;
      const step = ()=>{
        t += speed;
        const px = rayInFlight.start.x + rayInFlight.dir.x * t;
        const py = rayInFlight.start.y + rayInFlight.dir.y * t;
        draw(px,py);
        if (dist(px,py,target.x,target.y) < target.r+6){
          progressText.textContent = 'Target hit! +10 points.';
          rayInFlight = null;
          score += 10; scoreLabel.textContent = score;
          setTimeout(nextLevel,700);
          return;
        }
        if (px < -50 || px > W+50 || py < -50 || py > H+50 || t>maxT){
          progressText.textContent = 'Missed the target. Try again.';
          rayInFlight = null;
          draw();
          return;
        }
        requestAnimationFrame(step);
      };
      requestAnimationFrame(step);
    }

    function autoAim(){
      const toMirror = {x: mirror.x - source.x, y: mirror.y - source.y}; const L1 = Math.hypot(toMirror.x,toMirror.y);
      const toTarget = {x: target.x - mirror.x, y: target.y - mirror.y}; const L2 = Math.hypot(toTarget.x,toTarget.y);
      const v1 = {x: toMirror.x/L1, y: toMirror.y/L1};
      const v2 = {x: toTarget.x/L2, y: toTarget.y/L2};
      const bis = {x: v1.x + v2.x, y: v1.y + v2.y};
      const bn = Math.hypot(bis.x,bis.y);
      if (bn < 0.001) return;
      const normal = {x: bis.x/bn, y: bis.y/bn};
      const angle = Math.atan2(normal.y, normal.x) * 180/Math.PI - 90;
      mirror.angle = Math.max(-80, Math.min(80, angle));
      angleRange.value = mirror.angle; angleVal.textContent = mirror.angle.toFixed(0)+"°";
      progressText.textContent = 'Auto-aim adjusted mirror.';
      draw();
    }

    function lineIntersect(p0,p1,p2,p3){
      const s1_x = p1.x - p0.x; const s1_y = p1.y - p0.y;
      const s2_x = p3.x - p2.x; const s2_y = p3.y - p2.y;
      const s = (-s1_y * (p0.x - p2.x) + s1_x * (p0.y - p2.y)) / (-s2_x * s1_y + s1_x * s2_y);
      const t = ( s2_x * (p0.y - p2.y) - s2_y * (p0.x - p2.x)) / (-s2_x * s1_y + s1_x * s2_y);
      if (isFinite(s) && isFinite(t)){
        return {x: p0.x + (t * s1_x), y: p0.y + (t * s1_y)};
      }
      return null;
    }
    function pointOnSegment(p,a,b){
      const cross = (p.x - a.x)*(b.y - a.y) - (p.y - a.y)*(b.x - a.x);
      if (Math.abs(cross) > 1e-6) return false;
      const dot = (p.x - a.x)*(b.x - a.x) + (p.y - a.y)*(b.y - a.y);
      if (dot < 0) return false;
      const len2 = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y);
      if (dot > len2) return false;
      return true;
    }
    function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2,y1-y2); }

    function draw(px=null,py=null){
      ctx.clearRect(0,0,W,H);
      drawGrid();

      drawSource();

      drawMirror();

      drawTarget();

      const incDir = {x: mirror.x - source.x, y: mirror.y - source.y};
      const incLen = Math.hypot(incDir.x,incDir.y);
      const incEnd = {x: source.x + incDir.x/incLen * 1000, y: source.y + incDir.y/incLen * 1000};
      const a = mirror.angle*Math.PI/180;
      const mx1 = mirror.x + Math.cos(a)*mirror.length/2, my1 = mirror.y + Math.sin(a)*mirror.length/2;
      const mx2 = mirror.x - Math.cos(a)*mirror.length/2, my2 = mirror.y - Math.sin(a)*mirror.length/2;
      const inter = lineIntersect(source,incEnd,{x:mx1,y:my1},{x:mx2,y:my2});
      if (inter){
        drawArrow(source.x,source.y,inter.x,inter.y, {glow:true});
        const nx = Math.cos(a+Math.PI/2), ny = Math.sin(a+Math.PI/2);
        ctx.save(); ctx.globalAlpha = 0.25; ctx.beginPath(); ctx.moveTo(inter.x - nx*70, inter.y - ny*70); ctx.lineTo(inter.x + nx*70, inter.y + ny*70); ctx.strokeStyle = '#88e0e2'; ctx.lineWidth = 1; ctx.setLineDash([6,6]); ctx.stroke(); ctx.restore();
        const inc = {x:(inter.x-source.x)/dist(inter.x,inter.y,source.x,source.y), y:(inter.y-source.y)/dist(inter.x,inter.y,source.x,source.y)};
        const dot = inc.x*nx + inc.y*ny;
        const refl = {x: inc.x - 2*dot*nx, y: inc.y - 2*dot*ny};
        drawArrow(inter.x,inter.y, inter.x+refl.x*1000, inter.y+refl.y*1000, {color:'#ffd166'});
      } else {
        drawArrow(source.x,source.y,mirror.x,mirror.y,{});
      }

      if (px !== null && py !== null){
        ctx.beginPath(); ctx.arc(px,py,6,0,Math.PI*2); ctx.fillStyle='#ffd166'; ctx.fill();
      }

      ctx.fillStyle = '#cfeff0'; ctx.font = '13px Poppins'; ctx.fillText('Source', source.x-36, source.y-18);
    }

    function drawGrid(){
      ctx.save();
      ctx.globalAlpha = 0.06; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
      for (let x=0;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for (let y=0;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      ctx.restore();
    }

    function drawSource(){
      const g = ctx.createRadialGradient(source.x,source.y,4, source.x,source.y,60);
      g.addColorStop(0,'#e6fff7'); g.addColorStop(1,'rgba(230,255,247,0)');
      ctx.beginPath(); ctx.arc(source.x,source.y,20,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();
      ctx.beginPath(); ctx.arc(source.x,source.y,6,0,Math.PI*2); ctx.fillStyle='#e6fff7'; ctx.fill();
    }

    function drawMirror(){
      const a = mirror.angle*Math.PI/180;
      const x1 = mirror.x + Math.cos(a)*mirror.length/2, y1 = mirror.y + Math.sin(a)*mirror.length/2;
      const x2 = mirror.x - Math.cos(a)*mirror.length/2, y2 = mirror.y - Math.sin(a)*mirror.length/2;
      ctx.save();
      ctx.lineWidth = 6; ctx.lineCap='round'; ctx.strokeStyle = '#dbeffd';
      const grd = ctx.createLinearGradient(x1,y1,x2,y2); grd.addColorStop(0,'rgba(220,240,255,0.95)'); grd.addColorStop(0.5,'rgba(40,60,90,0.6)'); grd.addColorStop(1,'rgba(220,240,255,0.95)');
      ctx.strokeStyle = grd; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.restore();
      ctx.beginPath(); ctx.arc(mirror.x,mirror.y,8,0,Math.PI*2); ctx.fillStyle='#0f1724'; ctx.fill(); ctx.strokeStyle='#9ddfe0'; ctx.lineWidth=1; ctx.stroke();
    }

    function drawTarget(){
      ctx.save();
      ctx.beginPath(); ctx.arc(target.x,target.y,target.r,0,Math.PI*2);
      const g = ctx.createRadialGradient(target.x,target.y,2,target.x,target.y,target.r+10);
      g.addColorStop(0,'#fff1d6'); g.addColorStop(1,'#ffb86b');
      ctx.fillStyle = g; ctx.fill();
      ctx.restore();
    }

    function drawArrow(x1,y1,x2,y2, opts={color:'#9ee7e9', glow:false}){
      ctx.save();
      if (opts.glow){ ctx.shadowColor='#9ee7e9'; ctx.shadowBlur=18; }
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.strokeStyle = opts.color || '#9ee7e9'; ctx.lineWidth = 3; ctx.stroke();
      const ang = Math.atan2(y2-y1,x2-x1);
      ctx.beginPath(); ctx.moveTo(x2,y2); ctx.lineTo(x2 - 14*Math.cos(ang - Math.PI/6), y2 - 14*Math.sin(ang - Math.PI/6)); ctx.lineTo(x2 - 14*Math.cos(ang + Math.PI/6), y2 - 14*Math.sin(ang + Math.PI/6)); ctx.closePath(); ctx.fillStyle = opts.color || '#9ee7e9'; ctx.fill();
      ctx.restore();
    }

    (function init(){
      level = 1; score = 0; levelLabel.textContent = level; scoreLabel.textContent = score;
      resetLevel(); draw();
    })();

  </script>
</body>
</html>